# 数据结构

- 数据存储于内存时，决定了数据顺序和位置关系的便是“数据结构”。
- 链表
    - 链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便， 就是访问比较耗费时间。
    - 在链表中，数据一般都是分散存储于内存中的，无须存储在连续空间内。
    - 因为数据都是分散存储的，所以如果想要访问数据，只能从第 1 个数据开始，顺着指针的指向一一往下访问(这便是顺序访问)。
    - 如果想要添加数据或者删除数据，只需要改变添加位置前后 的指针指向就可以
    - 对链表的操作所需的运行时间到底是多少呢?在这里，我们把链表中的数据量记成 n。访问数据时，我们需要从链表头部开始查找(线性查找)，如果目标数据在链表最后的话，需要的时间就是 O(n)。
    - 另外，添加数据只需要更改两个指针的指向，所以耗费的时间与 n 无关。如果已 经到达了添加数据的位置，那么添加操作只需花费 O(1) 的时间。删除数据同样也只需 O(1) 的时间。
    - 虽然上文中提到的链表在尾部没有指针，但我们也可以在链表尾部使用指针，并且 让它指向链表头部的数据，将链表变成环形。这便是“循环链表”，也叫“环形链表”。 循环链表没有头和尾的概念。想要保存数量固定的最新数据时通常会使用这种链表。
    - 另外，上文链表里的每个数据都只有一个指针，但我们可以把指针设定为两个，并 且让它们分别指向前后数据，这就是“双向链表”。使用这种链表，不仅可以从前往后， 还可以从后往前遍历数据，十分方便。
    - 但是，双向链表存在两个缺点:一是指针数的增加会导致存储空间需求增加;二是 添加和删除数据时需要改变更多指针的指向。
- 数组
    - 数组也是数据呈线性排列的一种数据结构。与前一节中的链表不同，在数组中，访问数据十分简单，而添加和删除数据比较耗工夫。
    - 数据按顺序存储在内存的连续空间内。
    - 由于数据是存储在连续空间内的，所以每个数 据的内存地址(在内存上的位置)都可以通过 数组下标算出，我们也就可以借此直接访问目标数据(这叫作“随机访问”)。
    - 这里讲解一下对数组操作所花费的运行时间。假设数组中有 n 个数据，由于访问数 据时使用的是随机访问(通过下标可计算出内存地址)，所以需要的运行时间仅为恒定的 O(1)。
    - 但另一方面，想要向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要 O(n) 的时间。删除操作同理。
- 在链表和数组中，数据都是线性地排成一列。在链表中访问数据较为复杂，添加和 删除数据较为简单；而在数组中访问数据比较简单，添加和删除数据却比较复杂。
- 
- 栈
    - 栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新 书开始取。
    - 入栈：往栈中添加数据的操作叫作“入栈”（push）
    - 出栈：从栈中取出数据的操作叫作“出栈”（pop）
    - 像栈这种最后添加的数据最先被取出，即“后进先出”的结构，我们称为 Last In First Out，简称 LIFO。
    - 与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。
    - 栈只能在一端操作这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。
    - 深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。
- 队列
    - 与前面提到的数据结构相同，队列中的数据也呈线性排列。虽然与栈有些相似，但队列中添加和删除数据的操作分别是在两端进行的。
    - 入队：往队列中添加数据的操作叫作“入队”。
    - 出队：从队列中删除数据的操作叫作“出队”。
    - 像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为 First In First Out，简称 FIFO。
    - 与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。
    - “先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛。比如广度优先搜索算法，通常就会从搜索候补中选择最早的数据作为下一个顶点。此时，在候补顶点的管理上就可以使用队列。
- 哈希表
    - 哈希表存储的是由键（key）和值（value）组成的数据。
    - 数据量越多，线性查找耗费的时间就越长。但使用哈希表便可以解决这个问题。
    - 使用哈希函数（Hash）计算某个数据的键，也就是某个数据的哈希值。将得到的哈希值除以数组的长度，求得其余数。将这个数据存进数组的“余数”号箱子中。
    - 存储位置重复了的情况便叫作“冲突”。遇到这种情况，可使用链表在已有数据的后面继续存储新的数据。
    - 在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。
    - 如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。
- 堆
    - 堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。
    - 堆中的每个结点最多有两个子结点。树的形状取决于数据的个数。
    - 结点的排列顺序为从上到下，同一行里则为从左到右。
    - 在堆中存储数据时必须遵守这样一条规则 ：子结点必定大于父结点。因此，最小值被存储在顶端的根结点中。往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。
    - 添加数字：
        - 寻找新位置
        - 比较父节点
    - 取出数字：
        - 取出最上面数字
        - 将最后的数据移动到最顶端
        - 比较子节点，与较小的子节点交换位置
    - 堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为 O(1)。 
    - 另外，因为取出数据后需要将最后的数据移到最顶端，然后一边比较它与子结点数据的大小，一边往下移动，所以取出数据需要的运行时间和树的高度成正比。假设数据量为n，根据堆的形状特点可知树的高度为 log2n ，那么重构树的时间复杂度便为 O(logn)。 
    - 添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是 O(logn)。
    - 如果需要频繁地从管理的数据中取出最小值，那么使用堆来操作会非常方便。比如狄克斯特拉算法，每一步都需要从候补顶点中选择距离起点最近的那个顶点。此时，在顶点的选择上就可以用到堆。
- 二叉查找树
    - 二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构。数据存储于二叉查找树的各个结点中。
    - 二叉查找树有两个性质。第一个是每个结点的值均大于其左子树上任意一个结点的值。第二个是每个结点的值均小于其右子树上任意一个结点的值。
    - 首先，二叉查找树的最小结点要从顶端开始，往其左下 的末端寻找。
    - 反过来，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。
    - 添加数字
        - 首先，从二叉查找树的顶端结点开始寻找添加数字的位置。将想要添加的某数字与该结点中的值进行比较，小于它则往左移，大于它则往右移。
    - 删除结点
        - 如果需要删除的结点没有子结点，直接删掉该结点即可。
        - 如果需要删除的结点只有一个子结点，那么先删掉目标结点，然后把子结点移到被删除结点的位置上即可。
        - 如果需要删除的结点有两个子结点，那么先删掉目标结点，然后在被删除结点的左子树中寻找最大结点，最后将最大结点移到被删除结点的位置上。（但是根据二叉查找树的性质可知，移动“右子树中的最小结点”也没有问题。）
    - 查找结点
        - 从二叉查找树的顶端结点开始往下查找。和添加数据时一样，把某数字和结点中的值进行比较，小于该结点的值则往左移，大于则往右移。
    - 我们可以把二叉查找树当作是二分查找算法思想的树形结构体现。因为它具有前面提到的那两个性质，所以在查找数据或寻找适合添加数据的位置时，只要将其和现有的数据比较大小，就可以根据比较结果得知该往哪边移动了。
    - 比较的次数取决于树的高度。所以如果结点数为 n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。但是，如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了 O(n)。
    - 有很多以二叉查找树为基础扩展的数据结构，比如“平衡二叉查找树”。这种数据结构可以修正形状不均衡的树，让其始终保持均衡形态，以提高查找效率。
    - 另外，虽然文中介绍的二叉查找树中一个结点最多有两个子结点，但我们可以把子结点数扩展为 m（m 为预先设定好的常数）。像这种子结点数可以自由设定，并且形状均衡的树便是 B 树。
